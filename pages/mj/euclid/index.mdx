---
title: Euclidean rhythms
date: 2024-01-25
unlisted: true
description: Visualizing Euclidean rhythms
layout: code
---

import * as C from "../components";
import * as D from "./demos";

<C.Container>

<C.Section>

### Euclid's algorithm

<C.Box>

<C.Explanation>
Sometimes proclaimed as the oldest algorithm put down on paper, Euclid's
algorithm is enthralling in its recursive simplicity.

Euclid's version used a minus instead of a modulo (%), but otherwise here it is
in its full glory.

</C.Explanation>

{/* prettier-ignore */}
```js
const gcd = (n, m) => m ? gcd(m, n % m) : n
```

</C.Box>

</C.Section>

<C.Section>

### Euclidean rhythms

<C.Box>

<C.Explanation>

At the surface level it is calculating the GCD, the largest number that divides
both `n` and `m`. But really it is unravelling a number pair.

In 2005, Godfried Toussaint realized that Euclid's algorithm encodes most of the
drum beats used across the world. For example, here is `E(3, 8)`.

</C.Explanation>

<D.E38 />

</C.Box>

</C.Section>

<C.Section>

### Code

<C.Box>

<C.Explanation>

Here is an implementation of the algorithm described by Toussaint.

At each step, we "fold" the trailing part of the sequence into the leading part.
How much of the trailing part to fold is given by the value of `gcd(n, m)` at
that step.

</C.Explanation>

{/* prettier-ignore */}
```js
const E = (k, n) => {
    let s = Array(n).fill(0)
        .map((_, i) => (i < k ? [1] : [0]))

    let d = n - k
    n = Math.max(k, d)
    k = Math.min(k, d)
    let z = d

    while (z > 0 || k > 1) {
        for (let i = 0; i < k; i++)
            s[i].push(...s[s.length - 1 - i])
        s.splice(-k)
        z = z - k
        d = n - k
        n = Math.max(k, d)
        k = Math.min(k, d)
    }

    return s.flat()
}
```

</C.Box>

</C.Section>

<C.Section>

{/* TODO */}
{/* <D.SoundEuclidean /> */}

</C.Section>

</C.Container>
