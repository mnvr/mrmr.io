import { Pattern, Scheduler } from "@strudel.cycles/core";
import { initAudioOnFirstClick } from "@strudel.cycles/webaudio";
import * as React from "react";
import { initStrudel } from "strudel/init";
import { connectWebAudio } from "strudel/webaudio";
import { StrudelSong } from "types";
import { ensure } from "utils/ensure";

type UseStrudelPlaybackReturn = [
    /** If playback is currently active */
    isPlaying: boolean,
    /** Toggle playback */
    toggleIsPlaying: () => void,
    /** Has user started playback at least once */
    wasPlayingOnce: boolean
];

/**
 * A React hook to wrap the playback state and Strudel scheduling
 *
 * The hook will maintain a playback state, and expose a way to toggle the
 * playback state. It'll also return a boolean indicating if playback has
 * started at least once.
 *
 * @param song The {@link StrudelSong} to play.
 *
 * @returns A {@link UseStrudelPlaybackReturn} `[isPlaying, toggleIsPlaying,
 * wasPlayingOnce]`
 */
export const useStrudelPlayback = (
    song: StrudelSong
): UseStrudelPlaybackReturn => {
    const [isPlaying, setIsPlaying] = React.useState(false);
    const schedulerRef = React.useRef<Scheduler | null>(null);

    // Keep a reference to the pattern generated by the last song we were able
    // to successfully play. We will reset back to this if a new one cannot be
    // loaded (say due to syntax errors during live reload editing).
    const [lastPattern, setLastPattern] = React.useState<Pattern | undefined>(
        undefined
    );

    // Keep the canvas hidden until the first playback
    //
    // Hydra clears the canvas to a black color. This causes the black canvas to
    // be displayed until we render the first frame, which only happens if the
    // user starts playing.
    //
    // We could patch Hydra to instead clear to our background color. However,
    // it is perhaps simpler for now for us to just not show the canvas until
    // the first frame is rendered.
    const [hasUserInitiatedPlayback, setHasUserInitiatedPlayback] =
        React.useState(false);

    const toggleIsPlaying = () => {
        // Toggle the isPlaying state.
        setIsPlaying(!isPlaying);
        // Show the canvas (note that we never hide it again; see the comment
        // above `hasUserInitiatedPlayback` for more details).
        setHasUserInitiatedPlayback(true);
    };

    React.useEffect(() => {
        initStrudel();
        initAudioOnFirstClick();
    }, []);

    React.useEffect(() => {
        // Creating an AudioContext if the user has not clicked on the webpage
        // casues the browser to print a warning on the console. So only proceed
        // after the first playback has started.
        if (!hasUserInitiatedPlayback) return;

        const scheduler = connectWebAudio();
        schedulerRef.current = scheduler;

        let p: Pattern | undefined;
        try {
            p = song();
            setLastPattern(p);
        } catch (e) {
            console.warn(e);
            // If a live reload happens on autosave whilst we're in the middle
            // of making an edit to the currently playing song, there might be
            // syntax errors. Capture these (and keep playing the last
            // successfully played song) so that we don't break our flow.
            p = lastPattern;
        }

        scheduler.setPattern(ensure(p));

        if (isPlaying) scheduler.start();

        // Destroy the current scheduler, we'll recreate a new one, when the
        // song changes.
        return () => scheduler.stop();
    }, [hasUserInitiatedPlayback, song]);

    React.useEffect(() => {
        const scheduler = schedulerRef.current;

        // Initial playback has not been initiated.
        if (!scheduler) return;

        if (isPlaying) {
            scheduler.start();
        } else {
            scheduler.pause();
        }
    }, [isPlaying]);

    return [isPlaying, toggleIsPlaying, hasUserInitiatedPlayback];
};
